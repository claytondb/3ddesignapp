#include "IGESExporter.h"
#include <sstream>
#include <iomanip>
#include <ctime>
#include <algorithm>
#include <cmath>

namespace dc {

// Placeholder classes - replace with actual implementations
class NURBSSurface {
public:
    int degreeU = 3, degreeV = 3;
    std::vector<std::vector<glm::dvec3>> controlPoints;
    std::vector<std::vector<double>> weights;
    std::vector<double> knotsU, knotsV;
    bool isRational() const { return !weights.empty(); }
    double uMin = 0, uMax = 1, vMin = 0, vMax = 1;
};

class NURBSCurve {
public:
    int degree = 3;
    std::vector<glm::dvec3> controlPoints;
    std::vector<double> weights;
    std::vector<double> knots;
    bool isRational() const { return !weights.empty(); }
    double tMin = 0, tMax = 1;
    bool isPlanar = false;
    bool isClosed = false;
};

class Edge {
public:
    glm::dvec3 startPoint, endPoint;
    std::shared_ptr<NURBSCurve> curve;
};

class Face {
public:
    std::vector<std::shared_ptr<Edge>> outerLoop;
    std::vector<std::vector<std::shared_ptr<Edge>>> innerLoops;
    std::shared_ptr<NURBSSurface> surface;
    glm::vec3 color{0.8f, 0.8f, 0.8f};
};

class Body {
public:
    std::string name = "Body";
    std::vector<std::shared_ptr<Face>> faces;
    glm::vec3 color{0.7f, 0.7f, 0.7f};
};

class Model {
public:
    std::string name = "Model";
    std::vector<std::shared_ptr<Body>> bodies;
};

IGESExporter::IGESExporter()
    : m_directoryLineCount(0)
    , m_parameterLineCount(0)
{
}

IGESExporter::~IGESExporter()
{
}

bool IGESExporter::exportModel(const Model& model, const std::string& filename, const ExportOptions& options)
{
    m_options = options;
    m_entities.clear();
    m_entityMap.clear();
    m_directorySection.clear();
    m_parameterSection.clear();
    m_directoryLineCount = 0;
    m_parameterLineCount = 0;
    m_errorMessage.clear();
    
    try {
        // Export all bodies
        for (const auto& body : model.bodies) {
            exportBody(*body);
        }
        
        // Build file sections
        buildStartSection(filename);
        buildGlobalSection(filename);
        buildDirectorySection();
        buildParameterSection();
        
        // Write to file
        return writeFile(filename);
    }
    catch (const std::exception& e) {
        m_errorMessage = std::string("Export error: ") + e.what();
        return false;
    }
}

size_t IGESExporter::estimateFileSize(const Model& model, const ExportOptions& options) const
{
    size_t estimate = 1000; // Header overhead
    
    for (const auto& body : model.bodies) {
        estimate += 500;
        estimate += body->faces.size() * 3000;
    }
    
    return estimate;
}

void IGESExporter::buildStartSection(const std::string& filename)
{
    std::ostringstream ss;
    ss << "IGES file generated by " << m_options.applicationName << " " << m_options.applicationVersion;
    ss << ". Source file: " << filename;
    
    m_startSection = ss.str();
    
    // Pad to 72 characters per line
    while (m_startSection.length() < 72) {
        m_startSection += ' ';
    }
}

void IGESExporter::buildGlobalSection(const std::string& filename)
{
    std::ostringstream ss;
    
    // Parameter delimiter (1)
    ss << "1H,;";
    // Record delimiter (2)
    ss << "1H;;";
    // Product ID from sender (3)
    ss << "12H" << m_options.applicationName << ";";
    // File name (4)
    ss << filename.length() << "H" << filename << ";";
    // Native system ID (5)
    ss << "12H" << m_options.applicationName << ";";
    // Preprocessor version (6)
    ss << m_options.applicationVersion.length() << "H" << m_options.applicationVersion << ";";
    // Number of binary bits for integer rep (7)
    ss << "32;";
    // Maximum power of ten for single precision (8)
    ss << "38;";
    // Number of significant digits for single (9)
    ss << "6;";
    // Maximum power of ten for double precision (10)
    ss << "308;";
    // Number of significant digits for double (11)
    ss << "15;";
    // Product ID for receiver (12)
    ss << "12HModel Export;";
    // Model space scale (13)
    ss << "1.0;";
    // Unit flag (14) - 1=inches, 2=mm, etc
    int unitFlag = 2; // Default mm
    switch (m_options.units) {
        case ExportUnits::Inches: unitFlag = 1; break;
        case ExportUnits::Millimeters: unitFlag = 2; break;
        case ExportUnits::Feet: unitFlag = 4; break;
        case ExportUnits::Meters: unitFlag = 6; break;
        case ExportUnits::Centimeters: unitFlag = 5; break;
    }
    ss << unitFlag << ";";
    // Units name (15)
    ss << "2HMM;";
    // Maximum number of line weight gradations (16)
    ss << "1;";
    // Width of maximum line weight (17)
    ss << "0.01;";
    // Date and time of exchange file generation (18)
    std::time_t now = std::time(nullptr);
    std::tm* tm = std::localtime(&now);
    ss << "15H" << std::put_time(tm, "%Y%m%d.%H%M%S") << ";";
    // Minimum user-intended resolution (19)
    ss << "0.0001;";
    // Approximate maximum coordinate value (20)
    ss << "10000.0;";
    // Name of author (21)
    if (!m_options.authorName.empty()) {
        ss << m_options.authorName.length() << "H" << m_options.authorName << ";";
    } else {
        ss << ";";
    }
    // Author's organization (22)
    if (!m_options.organizationName.empty()) {
        ss << m_options.organizationName.length() << "H" << m_options.organizationName << ";";
    } else {
        ss << ";";
    }
    // IGES version (23) - 11 = IGES 5.3
    ss << m_options.igesVersion << ";";
    // Drafting standard (24) - 0 = none
    ss << "0;";
    // Date and time model created (25)
    ss << "15H" << std::put_time(tm, "%Y%m%d.%H%M%S") << ";";
    
    m_globalSection = ss.str();
}

void IGESExporter::buildDirectorySection()
{
    m_directorySection.clear();
    int directoryLine = 1;
    int parameterLine = 1;
    
    for (auto& entity : m_entities) {
        entity.directoryEntryLine = directoryLine;
        entity.parameterDataLine = parameterLine;
        
        // First directory line
        std::ostringstream line1;
        line1 << padRight(std::to_string(static_cast<int>(entity.type)), 8);  // Entity type
        line1 << padRight(std::to_string(entity.parameterDataLine), 8);       // Parameter data
        line1 << padRight(std::to_string(entity.structure), 8);               // Structure
        line1 << padRight(std::to_string(entity.lineFontPattern), 8);         // Line font pattern
        line1 << padRight(std::to_string(entity.level), 8);                   // Level
        line1 << padRight(std::to_string(entity.view), 8);                    // View
        line1 << padRight(std::to_string(entity.transformationMatrix), 8);    // Transformation matrix
        line1 << padRight(std::to_string(entity.labelDisplayAssoc), 8);       // Label display
        line1 << padRight(std::to_string(entity.statusNumber), 8);            // Status number
        
        m_directorySection.push_back(formatLine(line1.str(), 'D', directoryLine));
        directoryLine++;
        
        // Second directory line
        std::ostringstream line2;
        line2 << padRight(std::to_string(static_cast<int>(entity.type)), 8);  // Entity type (repeated)
        line2 << padRight(std::to_string(entity.lineWeight), 8);              // Line weight
        line2 << padRight(std::to_string(entity.colorNumber), 8);             // Color number
        line2 << padRight(std::to_string(entity.parameterLineCount), 8);      // Parameter line count
        line2 << padRight(std::to_string(entity.formNumber), 8);              // Form number
        line2 << padRight("", 8);                                             // Reserved
        line2 << padRight("", 8);                                             // Reserved
        line2 << padRight(entity.entityLabel, 8);                             // Entity label
        line2 << padRight(entity.entitySubscript, 8);                         // Entity subscript
        
        m_directorySection.push_back(formatLine(line2.str(), 'D', directoryLine));
        directoryLine++;
        
        // Count parameter lines for next entity
        parameterLine += entity.parameterLineCount;
    }
    
    m_directoryLineCount = directoryLine - 1;
}

void IGESExporter::buildParameterSection()
{
    m_parameterSection.clear();
    int parameterLine = 1;
    
    for (const auto& entity : m_entities) {
        // Split parameter data into 64-character chunks
        std::string data = entity.parameterData;
        int entityDirLine = entity.directoryEntryLine;
        
        while (!data.empty()) {
            size_t chunkSize = std::min(data.length(), (size_t)64);
            std::string chunk = data.substr(0, chunkSize);
            data = data.substr(chunkSize);
            
            // Pad to 64 characters
            while (chunk.length() < 64) {
                chunk += ' ';
            }
            
            // Add directory pointer (7 chars) and line number
            std::ostringstream line;
            line << chunk << padLeft(std::to_string(entityDirLine), 8);
            
            m_parameterSection.push_back(formatLine(line.str(), 'P', parameterLine));
            parameterLine++;
        }
    }
    
    m_parameterLineCount = parameterLine - 1;
}

bool IGESExporter::writeFile(const std::string& filename)
{
    std::ofstream file(filename, std::ios::out);
    if (!file.is_open()) {
        m_errorMessage = "Failed to open file for writing: " + filename;
        return false;
    }
    
    // Write start section
    std::string startLine = m_startSection;
    while (startLine.length() < 72) startLine += ' ';
    file << startLine.substr(0, 72) << "S      1\n";
    
    // Write global section
    int globalLineCount = 0;
    std::string globalData = m_globalSection;
    while (!globalData.empty()) {
        globalLineCount++;
        size_t chunkSize = std::min(globalData.length(), (size_t)72);
        std::string chunk = globalData.substr(0, chunkSize);
        globalData = globalData.substr(chunkSize);
        
        while (chunk.length() < 72) chunk += ' ';
        file << chunk << "G" << std::setw(7) << globalLineCount << "\n";
    }
    
    // Write directory section
    for (const auto& line : m_directorySection) {
        file << line << "\n";
    }
    
    // Write parameter section
    for (const auto& line : m_parameterSection) {
        file << line << "\n";
    }
    
    // Write terminate section
    file << "S" << std::setw(7) << 1 
         << "G" << std::setw(7) << globalLineCount 
         << "D" << std::setw(7) << m_directoryLineCount 
         << "P" << std::setw(7) << m_parameterLineCount 
         << std::string(40, ' ') << "T      1\n";
    
    file.close();
    return true;
}

std::string IGESExporter::formatLine(const std::string& content, char section, int lineNumber)
{
    std::ostringstream ss;
    std::string padded = content;
    while (padded.length() < 72) {
        padded += ' ';
    }
    ss << padded.substr(0, 72) << section << std::setw(7) << lineNumber;
    return ss.str();
}

std::string IGESExporter::padRight(const std::string& str, int width)
{
    std::string result = str;
    while ((int)result.length() < width) {
        result += ' ';
    }
    return result.substr(0, width);
}

std::string IGESExporter::padLeft(const std::string& str, int width)
{
    std::string result = str;
    while ((int)result.length() < width) {
        result = ' ' + result;
    }
    return result.substr(result.length() - width);
}

int IGESExporter::addEntity(IGESEntity& entity)
{
    // Calculate parameter line count
    int lineCount = (entity.parameterData.length() + 63) / 64;
    entity.parameterLineCount = std::max(1, lineCount);
    
    m_entities.push_back(entity);
    return m_entities.size();
}

int IGESExporter::exportPoint(const glm::dvec3& point)
{
    IGESEntity entity(IGESEntityType::POINT);
    
    glm::dvec3 p = transformPoint(point);
    double scale = m_options.getUnitScale();
    
    std::ostringstream params;
    params << static_cast<int>(IGESEntityType::POINT) << ",";
    params << formatReal(p.x * scale) << ",";
    params << formatReal(p.y * scale) << ",";
    params << formatReal(p.z * scale) << ",0;";
    
    entity.parameterData = params.str();
    
    return addEntity(entity);
}

int IGESExporter::exportLine(const glm::dvec3& start, const glm::dvec3& end)
{
    IGESEntity entity(IGESEntityType::LINE);
    
    glm::dvec3 p1 = transformPoint(start);
    glm::dvec3 p2 = transformPoint(end);
    double scale = m_options.getUnitScale();
    
    std::ostringstream params;
    params << static_cast<int>(IGESEntityType::LINE) << ",";
    params << formatReal(p1.x * scale) << ",";
    params << formatReal(p1.y * scale) << ",";
    params << formatReal(p1.z * scale) << ",";
    params << formatReal(p2.x * scale) << ",";
    params << formatReal(p2.y * scale) << ",";
    params << formatReal(p2.z * scale) << ";";
    
    entity.parameterData = params.str();
    
    return addEntity(entity);
}

int IGESExporter::exportCircularArc(const glm::dvec3& center, const glm::dvec3& start, const glm::dvec3& end)
{
    IGESEntity entity(IGESEntityType::CIRCULAR_ARC);
    
    glm::dvec3 c = transformPoint(center);
    glm::dvec3 s = transformPoint(start);
    glm::dvec3 e = transformPoint(end);
    double scale = m_options.getUnitScale();
    
    std::ostringstream params;
    params << static_cast<int>(IGESEntityType::CIRCULAR_ARC) << ",";
    params << formatReal(c.z * scale) << ",";     // Z displacement
    params << formatReal(c.x * scale) << ",";     // Center X
    params << formatReal(c.y * scale) << ",";     // Center Y
    params << formatReal(s.x * scale) << ",";     // Start X
    params << formatReal(s.y * scale) << ",";     // Start Y
    params << formatReal(e.x * scale) << ",";     // End X
    params << formatReal(e.y * scale) << ";";     // End Y
    
    entity.parameterData = params.str();
    
    return addEntity(entity);
}

int IGESExporter::exportNURBSCurve(const NURBSCurve& curve)
{
    IGESEntity entity(IGESEntityType::RATIONAL_B_SPLINE_CURVE);
    entity.formNumber = curve.isPlanar ? (curve.isClosed ? 5 : 1) : (curve.isClosed ? 6 : 2);
    
    int K = curve.controlPoints.size() - 1;  // Upper index of sum
    int M = curve.degree;
    int N = K + M + 1;  // Number of knots - 1
    int PROP1 = curve.isPlanar ? 1 : 0;
    int PROP2 = curve.isClosed ? 1 : 0;
    int PROP3 = !curve.isRational() ? 1 : 0;  // Polynomial (non-rational)
    int PROP4 = 0;  // Non-periodic
    
    double scale = m_options.getUnitScale();
    
    std::ostringstream params;
    params << static_cast<int>(IGESEntityType::RATIONAL_B_SPLINE_CURVE) << ",";
    params << K << "," << M << "," << PROP1 << "," << PROP2 << "," << PROP3 << "," << PROP4 << ",";
    
    // Knot sequence
    for (size_t i = 0; i < curve.knots.size(); i++) {
        params << formatReal(curve.knots[i]) << ",";
    }
    
    // Weights
    if (curve.isRational()) {
        for (size_t i = 0; i < curve.weights.size(); i++) {
            params << formatReal(curve.weights[i]) << ",";
        }
    } else {
        for (size_t i = 0; i <= (size_t)K; i++) {
            params << "1.0,";
        }
    }
    
    // Control points
    for (size_t i = 0; i < curve.controlPoints.size(); i++) {
        glm::dvec3 cp = transformPoint(curve.controlPoints[i]);
        params << formatReal(cp.x * scale) << ",";
        params << formatReal(cp.y * scale) << ",";
        params << formatReal(cp.z * scale) << ",";
    }
    
    // Parameter range
    params << formatReal(curve.tMin) << ",";
    params << formatReal(curve.tMax) << ",";
    
    // Unit normal (for planar curves)
    params << "0.0,0.0,1.0;";
    
    entity.parameterData = params.str();
    
    return addEntity(entity);
}

int IGESExporter::exportNURBSSurface(const NURBSSurface& surface)
{
    IGESEntity entity(IGESEntityType::RATIONAL_B_SPLINE_SURFACE);
    entity.formNumber = 0;  // Regular surface
    
    int K1 = surface.controlPoints.size() - 1;       // Upper index U
    int K2 = surface.controlPoints[0].size() - 1;    // Upper index V
    int M1 = surface.degreeU;
    int M2 = surface.degreeV;
    int PROP1 = 0;  // Not closed in U
    int PROP2 = 0;  // Not closed in V
    int PROP3 = !surface.isRational() ? 1 : 0;  // Polynomial
    int PROP4 = 0;  // Not periodic in U
    int PROP5 = 0;  // Not periodic in V
    
    double scale = m_options.getUnitScale();
    
    std::ostringstream params;
    params << static_cast<int>(IGESEntityType::RATIONAL_B_SPLINE_SURFACE) << ",";
    params << K1 << "," << K2 << "," << M1 << "," << M2 << ",";
    params << PROP1 << "," << PROP2 << "," << PROP3 << "," << PROP4 << "," << PROP5 << ",";
    
    // Knot sequence for U
    for (size_t i = 0; i < surface.knotsU.size(); i++) {
        params << formatReal(surface.knotsU[i]) << ",";
    }
    
    // Knot sequence for V
    for (size_t i = 0; i < surface.knotsV.size(); i++) {
        params << formatReal(surface.knotsV[i]) << ",";
    }
    
    // Weights (row by row)
    for (size_t i = 0; i < surface.controlPoints.size(); i++) {
        for (size_t j = 0; j < surface.controlPoints[i].size(); j++) {
            if (surface.isRational() && i < surface.weights.size() && j < surface.weights[i].size()) {
                params << formatReal(surface.weights[i][j]) << ",";
            } else {
                params << "1.0,";
            }
        }
    }
    
    // Control points (row by row)
    for (size_t i = 0; i < surface.controlPoints.size(); i++) {
        for (size_t j = 0; j < surface.controlPoints[i].size(); j++) {
            glm::dvec3 cp = transformPoint(surface.controlPoints[i][j]);
            params << formatReal(cp.x * scale) << ",";
            params << formatReal(cp.y * scale) << ",";
            params << formatReal(cp.z * scale) << ",";
        }
    }
    
    // Parameter range
    params << formatReal(surface.uMin) << ",";
    params << formatReal(surface.uMax) << ",";
    params << formatReal(surface.vMin) << ",";
    params << formatReal(surface.vMax) << ";";
    
    entity.parameterData = params.str();
    
    return addEntity(entity);
}

int IGESExporter::exportTrimmedSurface(const Face& face, int surfaceId, const std::vector<int>& curveIds)
{
    IGESEntity entity(IGESEntityType::TRIMMED_PARAMETRIC_SURFACE);
    entity.formNumber = 0;
    
    std::ostringstream params;
    params << static_cast<int>(IGESEntityType::TRIMMED_PARAMETRIC_SURFACE) << ",";
    params << surfaceId << ",";  // Surface to be trimmed
    params << "1,";              // N1 = 1 (outer boundary is outer boundary)
    params << curveIds.size() << ",";  // N2 = number of boundaries
    
    // Outer boundary pointer (first curve)
    if (!curveIds.empty()) {
        params << curveIds[0] << ",";
    }
    
    // Inner boundary pointers (remaining curves)
    for (size_t i = 1; i < curveIds.size(); i++) {
        params << curveIds[i];
        if (i < curveIds.size() - 1) params << ",";
    }
    params << ";";
    
    entity.parameterData = params.str();
    
    return addEntity(entity);
}

int IGESExporter::exportTransformationMatrix(const glm::dmat4& matrix)
{
    IGESEntity entity(IGESEntityType::TRANSFORMATION_MATRIX);
    
    std::ostringstream params;
    params << static_cast<int>(IGESEntityType::TRANSFORMATION_MATRIX) << ",";
    
    // Row-major order for IGES
    params << formatReal(matrix[0][0]) << ",";
    params << formatReal(matrix[1][0]) << ",";
    params << formatReal(matrix[2][0]) << ",";
    params << formatReal(matrix[3][0]) << ",";
    
    params << formatReal(matrix[0][1]) << ",";
    params << formatReal(matrix[1][1]) << ",";
    params << formatReal(matrix[2][1]) << ",";
    params << formatReal(matrix[3][1]) << ",";
    
    params << formatReal(matrix[0][2]) << ",";
    params << formatReal(matrix[1][2]) << ",";
    params << formatReal(matrix[2][2]) << ",";
    params << formatReal(matrix[3][2]) << ";";
    
    entity.parameterData = params.str();
    
    return addEntity(entity);
}

int IGESExporter::exportColorDefinition(const glm::vec3& color)
{
    IGESEntity entity(IGESEntityType::COLOR_DEFINITION);
    
    std::ostringstream params;
    params << static_cast<int>(IGESEntityType::COLOR_DEFINITION) << ",";
    params << formatReal(color.r * 100.0) << ",";  // Red (0-100)
    params << formatReal(color.g * 100.0) << ",";  // Green (0-100)
    params << formatReal(color.b * 100.0) << ",";  // Blue (0-100)
    params << "0H;";  // Color name (empty)
    
    entity.parameterData = params.str();
    
    return addEntity(entity);
}

int IGESExporter::exportFace(const Face& face)
{
    // Export the surface
    int surfaceId = 0;
    if (face.surface) {
        surfaceId = exportNURBSSurface(*face.surface);
    }
    
    // Export boundary curves
    std::vector<int> curveIds;
    
    // Outer loop
    for (const auto& edge : face.outerLoop) {
        if (edge->curve) {
            curveIds.push_back(exportNURBSCurve(*edge->curve));
        } else {
            // Create line
            curveIds.push_back(exportLine(edge->startPoint, edge->endPoint));
        }
    }
    
    // Inner loops
    for (const auto& loop : face.innerLoops) {
        for (const auto& edge : loop) {
            if (edge->curve) {
                curveIds.push_back(exportNURBSCurve(*edge->curve));
            } else {
                curveIds.push_back(exportLine(edge->startPoint, edge->endPoint));
            }
        }
    }
    
    // Create trimmed surface if we have curves
    if (surfaceId > 0 && !curveIds.empty()) {
        return exportTrimmedSurface(face, surfaceId, curveIds);
    }
    
    return surfaceId;
}

int IGESExporter::exportBody(const Body& body)
{
    // Export color if enabled
    int colorId = 0;
    if (m_options.igesIncludeColors) {
        colorId = exportColorDefinition(body.color);
    }
    
    // Export all faces
    std::vector<int> faceIds;
    for (const auto& face : body.faces) {
        int faceId = exportFace(*face);
        if (faceId > 0) {
            // Update color reference if applicable
            if (colorId > 0) {
                m_entities.back().colorNumber = colorId;
            }
            faceIds.push_back(faceId);
        }
    }
    
    // Return first face ID as body reference
    return faceIds.empty() ? 0 : faceIds[0];
}

std::string IGESExporter::formatParameterData(IGESEntityType type, const std::vector<std::string>& params)
{
    std::ostringstream ss;
    ss << static_cast<int>(type);
    
    for (const auto& param : params) {
        ss << "," << param;
    }
    
    ss << ";";
    return ss.str();
}

std::string IGESExporter::formatReal(double value) const
{
    std::ostringstream ss;
    ss << std::setprecision(10) << std::fixed << value;
    
    // Remove trailing zeros
    std::string result = ss.str();
    size_t dotPos = result.find('.');
    if (dotPos != std::string::npos) {
        size_t lastNonZero = result.find_last_not_of('0');
        if (lastNonZero > dotPos) {
            result = result.substr(0, lastNonZero + 1);
        }
        // Keep at least one digit after decimal
        if (result.back() == '.') {
            result += '0';
        }
    }
    
    return result;
}

std::string IGESExporter::formatInt(int value) const
{
    return std::to_string(value);
}

glm::dvec3 IGESExporter::transformPoint(const glm::dvec3& point) const
{
    glm::dmat4 transform = m_options.getCoordinateTransform();
    glm::dvec4 p4(point, 1.0);
    glm::dvec4 result = transform * p4;
    return glm::dvec3(result);
}

glm::dvec3 IGESExporter::transformDirection(const glm::dvec3& dir) const
{
    glm::dmat4 transform = m_options.getCoordinateTransform();
    glm::dvec4 d4(dir, 0.0);
    glm::dvec4 result = transform * d4;
    return glm::normalize(glm::dvec3(result));
}

} // namespace dc
